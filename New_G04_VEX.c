#pragma config(Sensor, in1, irSensor, sensorLineFollower)
#pragma config(Sensor, dgtl1, yMax, sensorTouch)
#pragma config(Sensor, dgtl2, yMin, sensorTouch)
#pragma config(Sensor, dgtl3, xMin, sensorTouch)
#pragma config(Sensor, dgtl4, xMax, sensorTouch)
#pragma config(Sensor, dgtl6, LED1, sensorLEDtoVCC)
#pragma config(Sensor, dgtl7, LED2, sensorLEDtoVCC)
#pragma config(Sensor, dgtl8, LED3, sensorLEDtoVCC)
#pragma config(Sensor, dgtl9, LED4, sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, LED5, sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, DefaultLED, sensorLEDtoVCC)
#pragma config(Motor, port2, xMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor, port3, yMotor, tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

//The power level/speed of the motors
#define SPEED 40
//How many rotations to move one cm
#define ROTPERCM 3
//Time for moving 1cm
#define ONECM 1333#pragma config(Sensor, in1, irSensor, sensorLineFollower)
#pragma config(Sensor, dgtl1, yMax, sensorTouch)
#pragma config(Sensor, dgtl2, yMin, sensorTouch)
#pragma config(Sensor, dgtl3, xMin, sensorTouch)
#pragma config(Sensor, dgtl4, xMax, sensorTouch)
#pragma config(Sensor, dgtl6, LED1, sensorLEDtoVCC)
#pragma config(Sensor, dgtl7, LED2, sensorLEDtoVCC)
#pragma config(Sensor, dgtl8, LED3, sensorLEDtoVCC)
#pragma config(Sensor, dgtl9, LED4, sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, LED5, sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, DefaultLED, sensorLEDtoVCC)
#pragma config(Motor, port2, xMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor, port3, yMotor, tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

//The power level/speed of the motors
#define SPEED 40
//How many rotations to move one cm
#define ROTPERCM 3
//Time for moving 1cm
#define ONECM 1333
//Standard wait time
#define STANARDWAIT 2000
//Threshold for activating the ir sensor on the black square
#define THRESHOLD 3000

////////////////////////////////////////////////////////////////////////////////

/*
	Function: void LEDS(int num, int state)

	Parameters:
	int num -- The number light number
	int state -- The state to set the light to

	Returns: none
*/
void LEDS(int num, int state){
	switch (num){
		case 1:
			SensorValue[LED1] = state;
			break;
		case 2:
			SensorValue[LED2] = state;
			break;
		case 3:
			SensorValue[LED3] = state;
			break;
		case 4:
			SensorValue[LED4] = state;
			break;
		case 5:
			SensorValue[LED5] = state;
			break;
		case 6:
			SensorValue[DefaultLED] = state;
			break;
	};
}


/*
  Function: void zero()
  Sends the motors to xMin and yMin to begin scanning

  Parameters: none

  Returns: none
*/
void zero() {
  motor[yMotor] = -1 * SPEED;
  motor[xMotor] = -1 * SPEED;
  short xin = 0;
  short yin = 0;
  while(1){
    if(SensorValue[xMin] != 0){motor[xMotor]=0;xin=1;}
    if(SensorValue[yMin] != 0){motor[yMotor]=0;yin=1;}
    if (xin == 1 && yin == 1) {break;}
    wait1Msec(10);
  }
}


/*
  Function: int xmax()
  Monitors the state of the xmax sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor is not pressed, 2 if pressed
*/
int xmax() {
	if (SensorValue[xMax] == 0) {
		return 1;
	 } else {
		return 2;
  }
}


/*
  Function: int xmin()
  Monitors the state of the xmin sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor is not pressed, 3 if pressed
*/
int xmin() {
	if (SensorValue[xMin] == 0) {
		return 1;
	} else {
		return 3;
	}
}


/*
  Function: int ymax()
  Monitors the state of the yMax sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor is not pressed, 5 if pressed
*/
int ymax() {
  if (SensorValue[yMax] == 0) {
  	return 1;
  	} else {
  	return 5;
  }
}


/*
  Function: int ymin()
  Monitors the state of the yMax sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor  not pressed, 7 if pressed
*/
int ymin() {
	if (SensorValue[yMin] == 0) {
  	return 1;
  } else {
  	return 7;
	}
}


/*
  Function: void yInc()
  Increment the Y motor by 1cm, it should make sure that make that yMax is not depressed

  Parameters: None

  Returns: None
 */
void yInc(){
  resetMotorEncoder(yMotor);
  motor[yMotor] = SPEED;
  clearTimer(T2);
  while((time1(T2) < ONECM) && SensorValue[yMax] == 0){}
  motor[yMotor] = 0;
}


/*
  Function: void pause_yInc()
  Pauses the x motor then uses yInc() to increment the y then resumes the x motor

  Parameters: None

  Returns: None
 */
void pause_yInt(){
  short temp = motor[xMotor];
  motor[xMotor] = 0;
  yInc();
  motor[xMotor] = temp;
}


/*
  Function: void moveX(int dir)
  Moves the x motor left or right depending on dir

  Parameters:
  int dir -- Moves x to xMin if -1 and toward xMax if 1

  Returns: None
 */
void moveX(int dir) {
  motor[xMotor] = dir * SPEED;
  pause_yInt();
  wait1Msec(STANARDWAIT);
}


/*
  Function: int numtobin(int num)
  Converts a number to binary

  Parameters:
	int num -- The number to convert

  Returns: Int of bin representation
 */
 int numtobin(int num){
   int bin = 0;
   short temp, i=1,next=1;
   while(num!=0){
     temp = num%2;
     num/=2;
     next++;
     bin += temp * i;
     i *= 10;
   }
   return bin;
 }


 /*
   Function: void turnonlights(int n)
   Turns on the lights representing the number in binary

   Parameters:
 	 int n -- The number to represent in the leds

   Returns: none
  */
 void turnonlights(int n){
   int i = 1,number = numtobin(n),tmp;
   for(; i < 5;i++){
     tmp = number % 10;
     LEDS(i,tmp);
     number = number / 10;
   }
 }

////////////////////////////////////////////////////////////////////////////////
task main(){
	//Initialize the robot
  zero();
  int t = 0;
	short count = 0,irVal = 0;
  clearTimer(T3);

  while(1){
    //Update the irVal and set that to the DefaultLed value
    SensorValue[DefaultLED] = irVal = ((SensorValue[irSensor] > THRESHOLD) ? 1 : 0);
    if (time1[T3]>=t && irVal){
      turnonlights(++count);
    	t = time1[T3] + ONECM;
		}
    //      2      3      5      7
    switch (xmax()*xmin()*ymax()*ymin()) {
      //xMax depressed
      case 2:
        moveX(-1);
        break;

      //xMin depressed
      case 3:
        moveX(1);
        break;

			//xMax and yMax
      case 10:
      	moveX(-1);
  			break;

      //xMax and yMin
      case 14:
        moveX(-1);
        break;

      //xMin and yMax depressed
      case 15:
				//Halts the motors
        motor[xMotor] = 0;
        motor[yMotor] = 0;
				turnonlights(0);
				exit(0);
        break;

      //Start xMin and yMin
      case 21:
        motor[xMotor] = SPEED;
        wait1Msec(STANARDWAIT);
        break;
    }
  }
}

//Standard wait time
#define STANARDWAIT 2000
//Threshold for activating the ir sensor on the black square
#define THRESHOLD 3000

////////////////////////////////////////////////////////////////////////////////

/*
	Function: void LEDS(int num, int state)

	Parameters:
	int num -- The number light number
	int state -- The state to set the light to

	Returns: none
*/
void LEDS(int num, int state){
	switch (num){
		case 1:
			SensorValue[LED1] = state;
			break;
		case 2:
			SensorValue[LED2] = state;
			break;
		case 3:
			SensorValue[LED3] = state;
			break;
		case 4:
			SensorValue[LED4] = state;
			break;
		case 5:
			SensorValue[LED5] = state;
			break;
		case 6:
			SensorValue[DefaultLED] = state;
			break;
	};
}


/*
  Function: void zero()
  Sends the motors to xMin and yMin to begin scanning

  Parameters: none

  Returns: none
*/
void zero() {
  motor[yMotor] = -1 * SPEED;
  motor[xMotor] = -1 * SPEED;
  short xin = 0;
  short yin = 0;
  while(1){
    if(SensorValue[xMin] != 0){motor[xMotor]=0;xin=1;}
    if(SensorValue[yMin] != 0){motor[yMotor]=0;yin=1;}
    if (xin == 1 && yin == 1) {break;}
    wait1Msec(10);
  }
}


/*
  Function: int xmax()
  Monitors the state of the xmax sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor is not pressed, 2 if pressed
*/
int xmax() {
	if (SensorValue[xMax] == 0) {
		return 1;
	 } else {
		return 2;
  }
}


/*
  Function: int xmin()
  Monitors the state of the xmin sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor is not pressed, 3 if pressed
*/
int xmin() {
	if (SensorValue[xMin] == 0) {
		return 1;
	} else {
		return 3;
	}
}


/*
  Function: int ymax()
  Monitors the state of the yMax sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor is not pressed, 5 if pressed
*/
int ymax() {
  if (SensorValue[yMax] == 0) {
  	return 1;
  	} else {
  	return 5;
  }
}


/*
  Function: int ymin()
  Monitors the state of the yMax sensor and returns a value based on that state

  Parameters: none

  Returns: 1 if sensor  not pressed, 7 if pressed
*/
int ymin() {
	if (SensorValue[yMin] == 0) {
  	return 1;
  } else {
  	return 7;
	}
}


/*
  Function: void yInc()
  Increment the Y motor by 1cm, it should make sure that make that yMax is not depressed

  Parameters: None

  Returns: None
 */
void yInc(){
  resetMotorEncoder(yMotor);
  motor[yMotor] = SPEED;
  clearTimer(T2);
  while((time1(T2) < ONECM) && SensorValue[yMax] == 0){}
  motor[yMotor] = 0;
}


/*
  Function: void pause_yInc()
  Pauses the x motor then uses yInc() to increment the y then resumes the x motor

  Parameters: None

  Returns: None
 */
void pause_yInt(){
  short temp = motor[xMotor];
  motor[xMotor] = 0;
  yInc();
  motor[xMotor] = temp;
}


/*
  Function: void moveX(int dir)
  Moves the x motor left or right depending on dir

  Parameters:
  int dir -- Moves x to xMin if -1 and toward xMax if 1

  Returns: None
 */
void moveX(int dir) {
  motor[xMotor] = dir * SPEED;
  pause_yInt();
  wait1Msec(STANARDWAIT);
}


/*
  Function: int numtobin(int num)
  Converts a number to binary

  Parameters:
	int num -- The number to convert

  Returns: Int of bin representation
 */
 int numtobin(int num){
   int bin = 0;
   short temp, i=1,next=1;
   while(num!=0){
     temp = num%2;
     num/=2;
     next++;
     bin += temp * i;
     i *= 10;
   }
   return bin;
 }


 /*
   Function: void turnonlights(int n)
   Turns on the lights representing the number in binary

   Parameters:
 	 int n -- The number to represent in the leds

   Returns: none
  */
 void turnonlights(int n){
   int i = 1,tmp,number = numtobin(n);
   for(; i < 6;i++){
     tmp = number % 10;
     LEDS(i,tmp);
     number = number / 10;
   }
 }

 //Used to debug certain aspects of the robot
 short count=0;
 short irVal = 0;
 short ival = SensorValue[irSensor];
////////////////////////////////////////////////////////////////////////////////
task main(){
	//Initialize the robot
  zero();
  int t = 0;
  clearTimer(T3);
  turnonlights(0);

  while(1){
    //Update the irVal and set that to the DefaultLed value
    ival = SensorValue[irSensor];
    SensorValue[DefaultLED] = irVal = ((SensorValue[irSensor] > THRESHOLD) ? 1 : 0);
    if (time1[T3]>=t && irVal){
      turnonlights(++count);
    	t = time1[T3] + ONECM;
		}
    //      2      3      5      7
    switch (xmax()*xmin()*ymax()*ymin()) {
      //xMax depressed
      case 2:
        moveX(-1);
        break;

      //xMin depressed
      case 3:
        moveX(1);
        break;

			//xMax and yMax
      case 10:
      	moveX(-1);
  			break;

      //xMax and yMin
      case 14:
        moveX(-1);
        break;

      //xMin and yMax depressed
      case 15:
				//Halts the motors
        motor[xMotor] = 0;
        motor[yMotor] = 0;
				turnonlights(0);
        break;

      //Start xMin and yMin
      case 21:
        motor[xMotor] = SPEED;
        wait1Msec(STANARDWAIT);
        break;
    }
  }
}
